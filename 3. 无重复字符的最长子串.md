## 题目



https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/



> 公众号 《java编程手记》记录JAVA学习日常，分享学习路上点点滴滴，从入门到放弃，欢迎关注



## 描述



给定一个字符串，请你找出其中不含有重复字符的 **最长子串** 的长度。



示例 1:



```java
输入: s = "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3
```



示例 2:



```java
输入: s = "bbbbb"
输出: 1
解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
```



示例 3:



```java
输入: s = "pwwkew"
输出: 3
解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
  请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。
```



示例 4:

```java
输入: s = ""
输出: 0

```



```java
0 <= s.length <= 5 * 104
s 由英文字母、数字、符号和空格组成
```



## Solution



### 解法



#### 暴力思路

> 检查重复字符串的思路有哪些？

* 两次遍历循环字符串
  * 第一层循环记录头部信息
  * 第二层循环用来滑动数据
  * 将第二层数据存入到`Set`中
    * 存入之前判断Set中是否已经存在字符串
      * 有则`BREAK`，进入下一个外层循环
      * 无则计算最新的结果长度，并且将当前字符串存入到`Set`中
    * `每当第二次循环完成之后，清空Set，防止影响下一个第一层循环的数据`

![image-20210412233857464](https://i.loli.net/2021/04/12/GXzSjuVsvrdyHJZ.png)



#### CODE

```java
class Solution {
     public int lengthOfLongestSubstring(String s) {
       int res = 0 ;
       Set<Character> set = new HashSet<>();
       for(int i = 0 ; i < s.length();i++){
           for(int j = i ; j < s.length() ; j++){
               if(set.contains(s.charAt(j))){
                  break;
               }
               if(j-i+1 > res){
                   res = j-i+1;
               }
               set.add(s.charAt(j));
           }
           set.clear();
       }
       return res;
    }
}
```



#### 复杂度

* 时间复杂度：`O(N^2)`，`N` 为`S`的长度
* 空间复杂度：`O(N^2)`，`N`为`S`的长度





#### 结果



* 执行用时：`99` ms, 在所有 Java 提交中击败了`12.37`%的用户
* 内存消耗：`38.7` MB, 在所有 Java 提交中击败了`39.62`%的用户



### 简洁版本



#### 解题思路



跟上面的思路差不多，唯一区别在于判断越界的地方，当新生成的结果`last != res/10`时，则说明整数溢出



#### CODE

```java
class Solution {
     public int lengthOfLongestSubstring(String s) {
         
       int length = s.length();
       if(length == 0){
           return 0;
       }
       if(s.equals(" ")){
           return 1;
       }
       int res = 0 ;
       //快指针
       int fast = 0 ;
       //慢指针 
       int slow = 0 ;
       //索引，空间换时间
       Map<Character,Integer> map = new HashMap<>();
       for(;fast<length;fast++){
           Character c = s.charAt(fast);
        if(map.containsKey(c)){
            //更新slow
            if( map.get(c) > slow){
                    slow = map.get(c);
            }
        }
        //mei
        if((fast-slow+1)>res){
                res = (fast-slow+1);
        }
         //更新c的位置
        map.put(c,fast+1);

       }
       return res ;
    }
}
```



#### 复杂度



* 时间复杂度：`O(log(x))`，`x` 中大约有 `log 10(x)` 位数字
* 空间复杂度：`O(1)`



#### 结果

* 执行用时：`1` ms, 在所有 Java 提交中击败了`100.00%`的用户

* 内存消耗：`35.3` MB, 在所有 Java 提交中击败了`91.96%`的用户









#### CODE

```java
class Solution {
     public int lengthOfLongestSubstring(String s) {
         
       int length = s.length();
       if(length == 0){
           return 0;
       }
       if(s.equals(" ")){
           return 1;
       }
       int res = 0 ;
       //快指针
       int fast = 0 ;
       //慢指针 
       int slow = 0 ;
       //索引，空间换时间
       Map<Character,Integer> map = new HashMap<>();
       for(;fast<length;fast++){
           Character c = s.charAt(fast);
        if(map.containsKey(c)){
            //更新slow
            if( map.get(c) > slow){
                    slow = map.get(c);
            }
        }
        //mei
        if((fast-slow+1)>res){
                res = (fast-slow+1);
        }
         //更新c的位置
        map.put(c,fast+1);

       }
       return res ;
    }
}
```







### 参考



https://www.bilibili.com/video/BV1St4y1k72y?from=search&seid=12825150742902127069







