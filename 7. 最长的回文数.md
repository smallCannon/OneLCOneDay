1. 抽象数组，下标，求解值（求和值，最大值，最小值）
2. 抽象算法，func(数组，当前下标，求解值)
3. 找边界，当前递归的最终出路，不可能一直递归下去，需要有突破的地方
4. 暴力递归之后，需要抽象总结算法不足，重复计算等等，优化算法













```java
class Solution {
    public String longestPalindrome(String s) {
         int len = s.length();
         String res = "";
      	 //如果小于2，直接返回
         if(len < 2){
             return s;
         }
         for(int i =0;i<len ; i++){
           	//奇数情况，两个均为i
            res = sub(s,i,i,res)
            //偶数情况，中心数为i,i+1
            res = sub(s,i,i+1,res);
         }
         return res;
    }

    public String sub(String s,int m,int n,String res){
      	//m,n在范围内，并且s[m] == s[n]
        while(m>=0 && (n < s.length()) && (s.charAt(m) == s.charAt(n))){
          	//扩散，对应--
            m--;
          	//扩散,对应++
            n++;
        }
      	//这里其实是(n-1)-(m+1)-1,在上面while之后，会m--以及n++,比实际位置偏差一位
        if((n-m-1) > res.length()){
          	//截取m+1位置，到n-1的地方，上面while比实际位置偏差一位，所以m需要+1，n不需要-1
            res=s.substring(m+1,n);
        }
        return res;
    }
}

```



* 执行用时：37 ms, 在所有 Java 提交中击败了76.50%的用户

* 内存消耗：39 MB, 在所有 Java 提交中击败了58.36%的用户