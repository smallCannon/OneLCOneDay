## 题目



https://leetcode-cn.com/problems/reverse-integer/



> 公众号 《java编程手记》记录JAVA学习日常，分享学习路上点点滴滴，从入门到放弃，欢迎关注



## 描述



给你一个 `32` 位的有符号整数 `x` ，返回将 `x` 中的数字部分反转后的结果。



如果反转后整数超过 `32` 位的有符号整数的范围 `[−231,  231 − 1]` ，就返回 `0`

假设环境不允许存储 `64` 位整数（有符号或无符号）



示例 1：

```python
输入：x = 123
输出：321
示例 2：

输入：x = -123
输出：-321
示例 3：

输入：x = 120
输出：21
示例 4：

输入：x = 0
输出：0
```



## Solution



### 解法



#### 解题思路

>  反转整数的思路有哪些？

* 把整数变成字符串，再反转字符串，再转换整形，判断边界问题
* 通过栈数据结构，先从整数的尾部依次入栈，再出栈组合成新的数字



第一种整数变字符串，然后反转这种就不做介绍了，我们主要以栈结构这种思路来解题，这里我们不需要使用栈的数据结构，将整数的尾部依次取出，然后拼接到新的数字即可，如下图所示，通过取模拿到最后一位的结果数据，再依次拼接到最终的结果上即可，每次的结果就等于 `res = res*10 + x%10`,当最后`x`的值为`0` ，则整体运算结束，最后判断是否超越边界即可



![image-20210411212913523](https://i.loli.net/2021/04/11/ketoiNXjbMJY82O.png)





#### CODE

```java
class Solution {
    public int reverse(int x) {
        long result = 0;
        long absX = Math.abs (x);
        while (absX != 0) {
            long pop = absX % 10; //取到3
            absX = absX / 10;    //去掉3
            result = result * 10 + pop;  //返回值
        }
        //1 << 31 是 -2147483648 ， (1 << 31) - 1 是 2147483647
        if (result <= 1 << 31 || result > (1 << 31) - 1) {
            return 0;
        }
        if (x > 0) {
            return (int) num;
        }
        if (x < 0) {
            return (int) -num;
        }
        return 0;
    }
}
```



#### 复杂度

* 时间复杂度：`O(log(x))`，`x` 中大约有 `log 10(x)` 位数字
* 空间复杂度：`O(1)`





#### 结果



* 执行用时：`1` ms, 在所有 Java 提交中击败了`100.00%`的用户

* 内存消耗：`35.6` MB, 在所有 Java 提交中击败了`55.86%`的用户



### 简洁版本



#### 解题思路



跟上面的思路差不多，唯一区别在于判断越界的地方，当新生成的结果`last != res/10`时，则说明整数溢出



#### CODE

```java
class Solution {
    public int reverse(int x) {
        int res = 0;
        int last = 0;
        while(x!=0) {
            //每次取末尾数字
            int tmp = x%10;
            last = res;
            res = res*10 + tmp;
            //判断整数溢出
            if(last != res/10)
            {
                return 0;
            }
            x /= 10;
        }
        return res;
    }
}
```



#### 复杂度



* 时间复杂度：`O(log(x))`，`x` 中大约有 `log 10(x)` 位数字
* 空间复杂度：`O(1)`



#### 结果

* 执行用时：`1` ms, 在所有 Java 提交中击败了`100.00%`的用户

* 内存消耗：`35.3` MB, 在所有 Java 提交中击败了`91.96%`的用户













